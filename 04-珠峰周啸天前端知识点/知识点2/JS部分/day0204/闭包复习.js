/*
 基于VAR声明和LET声明的区别？
   1. var具备变量提升，let不具备变量提升
   2. 在全局上下文「EC(G)」中，基于var声明的变量，是存放在GO(window全局对象)中的，但是基于let声明的变量，是存储在VO(G)全局变量对象中！
   3. let不允许重复声明（但是var可以）：无论之前基于何种方式声明了这个变量，都不允许再基于let/const声明
   4. let会产生块级上下文（var不会）：在除对象及函数以外的大括号中，一但出现let/const等操作，则此大括号会产生块级私有上下文！！
 */


/*
 循环没有产生块级上下文，都是在全局上下文中处理的
   + 也就是i是全局变量 
   + 定时器是异步操作：创建定时器，会把其放在WebAPI队列中监听，循环这个同步操作会继续执行
   -----
   循环5轮，设置五个定时器在监听(效果：间隔一秒会有一个定时器可执行)；循环结束后，全局的i=5；
 */
/* for (var i = 0; i < 5; i++) {
    setTimeout(function () {
        // 每一个定时器触发执行，函数中遇到的i不是函数私有的，则向其上级上下文中进行查找
        // 而其上级上下文是EC(G) --> 找到的i都是5
        console.log(i);
    }, (i + 1) * 1000);
} */

// 需求：循环创建定时器，定时器依次执行的时候，可把之前循环阶段的索引输出 “每间隔1秒，分别输出：0/1/2/3/4”
// 解决思路：自己构建闭包，让其介于 EC(G) 和 定时器私有上下文 之间；每循环一轮都创建一个闭包，闭包中有私有的i变量，存储着当时循环的索引；

/* // 代码形式3：
// setTimeout(function(n){},2000,'哈哈')  在2秒后，定时器方法触发执行，会把'哈哈'传递给n
// 内部机制依然是基于闭包实现的！！
for (var i = 0; i < 5; i++) {
    setTimeout(function (i) {
        console.log(i); //i是函数中私有的
    }, (i + 1) * 1000, i);
} */

/* // 代码形式2：
for (let i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i);
    }, (i + 1) * 1000);
} */

/* // 代码形式1：
for (var i = 0; i < 5; i++) {
    (function (i) {
        setTimeout(function () {
            console.log(i);
        }, (i + 1) * 1000);
    })(i);
} */