如何部署我们的产品
  1. 购买服务器「阿里云服务器 ECS」
    https://www.aliyun.com/
    + 推荐配置  系统:linux(或乌班图)  部署工具:nginx  
    + 后端程序根据语言不同，选择安装相应的环境和数据库
    ----
    购买完成服务器之后，服务器会有一个“外网IP地址”，例如：123.57.205.204
    把自己的代码上传到服务器指定位置「基于FTP上传工具 -> FileZilla」
    基于Nginx等工具开始部署我们的项目「构建web服务器」：需要指定一个端口号(一台服务器可以部署很多项目，端口号就是用来区分不同项目的)
    ----
    这样的操作结束后，就可以基于 http://123.57.205.204:端口号/资源的路径名称 访问我们的项目了！！

  2. 购买域名「域名就是给外网IP起一个好记忆的名字」
    https://wanwang.aliyun.com/
    顶级域名：qq.com  「我们只需要买顶级域名即可，其余的域名是自己分配的」
    一级域名：www.qq.com
    二级域名：sports.qq.com
    三级域名：kbs.sports.qq.com
    ----
    域名后缀：.com国际域名  .cn中文域名  .gov政府  .edu学校  .org官方  .net系统  .vip会员  ...
    ----
    域名解析：让域名和服务器的外网IP可以关联在一起「DNS服务器:域名解析服务器」
    域名备案

面试题：用户在地址栏中输入一个网址，到看到整个页面，中间都经历了啥？
  第一步：URL解析
    @1 传输协议
     http 超文本传输协议：传输的信息除了文本以外，还可以是一些富媒体资源（例如：传输音视频、图片等）
     https 经过加密(SSL)处理的http：所以更安全，涉及支付类的产品，基本上都是基于https来处理的
     ftp 文件传输协议：主要运用在基于相关的工具，把写好的代码上传到服务器进行部署，或者从服务器下载文件
    @2 端口号
     作用：用来区分同一台服务器上的不同服务的，端口号的取值范围 0~65535 之间！！
     浏览器的默认端口号「用户自己在地址中没有写端口号，浏览器会根据当前的传输协议，默认把端口号加上」
       http -> 80
       https -> 443
       ftp -> 21ao 
    @3 查询字符串（问号传参）
     作用：
       客户端可以基于问号传参的方式，把信息传递给服务器；
       也用于客户端两个页面之间的信息传输(例如：从列表页进入详情页，可以基于问号传参，把列表页中的信息传递给详情)；
    @4 HASH(哈希)值
     作用：
       基于哈希值实现锚点定位！！
       基于哈希值实现HASH路由！！
    -------
    如果URL地址中出现“中文、空格、或者一些特殊符号”，在信息传输的时候，可能出现乱码的问题！解决方案：
      传输之前，先把信息编码
      对方获取到信息后，把编码的信息再解码即可
    方法一：encodeURI/decodeURI 用于对整个URL的编码处理，因为它会对“中文及空格”进行编码 
    方法二：encodeURIComponent/decodeURIComponent 用于对问号传参的信息进行编码处理，因为除了对中文和空格进行编码外，对一些特殊符号也会编码！！
    -----上述两种方法是最常用的！！「一般的编程语言中都有这些API」
    方法三：escape/unescape 因为很多后端语言中没有这个API，所以一般只用于客户端页面之间，信息传输的编码

  第二步：缓存检查
    我们可以给“静态资源”（例如：html、css、js、图片...，不含ajax请求的数据）设置缓存机制
      + 都是服务器进行设置「例如：nginx部署的时候，可以设置相关配置」
      + 都是客户端浏览器自己，自主的去完成缓存的检查和处理「不需要前端写任何的代码」
    @1 强缓存
      + 如果服务器设置了强缓存机制，则在返回的“响应头”中，会包含相关的字段信息
        + Expires:存储具体的过期时间  ->HTTP/1.0版本
        + Cache-Control:存储多久后过期(单位是秒) ->HTTP/1.1版本
        + 状态码：200
      + 客户端浏览器在接收响应的资源信息后，发现这两个字段，会把资源和字段的相关信息，缓存在客户端
        缓存的位置
        + 会在虚拟内存中存放「内存条：Memory Cache」 -> 页面关闭，缓存清空
        + 会在物理内存中存放「硬盘：Disk Cache」 -> 页面关闭，缓存不动
      + 下一次再次访问这个页面，浏览器首先会去本地缓存中进行查找，验证缓存的有效性(有且未过期)
        + 缓存生效：直接从缓存获取 「状态码依然是200」
        + 缓存失效：再去服务器重新获取，并且把资源和相关的字段信息重新缓存在本地
      ------
      强缓存是前端性能优化非常重要方式，可以加快页面第二次及以后的打开速度！！所以真实项目中，我们的CSS/JS/图片等资源，都会设置强缓存机制！！
      但是一定要切记、切记、切记...HTML页面不能设置强缓存！！！因为我们要保证，即便本地缓存未失效，但是服务器相关资源一但更新，我们还需要从服务器重新获取！！
         A.HTML一定不能设置强缓存，要保证，HTML每一次都是从服务器获取（html页面是一切的起始）
         B.如果服务器资源有更新，则CSS/JS等文件的名字一定会被更换，而HTML中或导入新的文件！！「webpack」

    @2 协商缓存
      “协商”缓存是在强缓存失效，或者没有设置的情况下，进行处理的！！
      第一次访问网站：本地没有缓存，从服务器获取，如果服务器开启了协商缓存，则会在响应头中携带两个字段；客户端浏览器获取资源信息后，渲染的同时，把资源信息及标识都缓存起来！！
        + Last-Modified:存储资源最后一次更新的时间   -> HTTP/1.0
        + ETag:存储资源最后一次更新产生的唯一标识 -> HTTP/1.1
      第二次访问网站：即便本地有缓存，也要向服务器发送请求，并且把Last-Modified和Etag值传递给服务器；服务器接收到请求后，先获取两个标识值！！
        基于请求头，把之前存储的标识信息传递给服务器
        + If-Modified-Since : 获取的是Last-Modified值
        + If-Node-Match：获取的是ETag值
      服务器会把接收到的信息（最后一次更新的时间或者标识）和服务器现有这个资源的信息，进行对比：
        + 如果一样：资源从上次获取到现在，没有更新过
          服务器只需要返回304状态码即可
          浏览器获取的如果是304，则从本地缓存中获取信息渲染！！
        + 如果不一样：资源更新过
          把最新的资源和最后的修改时间(或标识)，返回给客户端，让客户端重新渲染和存储「状态码200」

  第三步：DNS解析
    目的：基于域名，到DNS服务器上，找到服务器的外网IP
    它也可能出现DNS解析的缓存记录「上一次从DNS服务器解析后，会把解析的结果放在本地缓存一会，所以下一次，再次访问这个域名，首先看本地是否有缓存的记录...」
      递归查询：主要是查找本地的DNS解析缓存记录的
      迭代查询：主要是去DNS服务器上进行解析
    每一次DNS解析时间预计在20~120毫秒!
      从这个角度讲，项目中使用的域名越少越好！！这样需要我们在部署的时候，把所有资源（含：html/css/js/图片/数据等等）都部署在相同服务器的同一个服务器下！！这样所有资源信息的访问，只会用到这个一个域名！！
    但是往往在真实项目中，我们会把资源分服务器进行部署！！
      一方面资源可以合理的进行利用，另外一方面，减轻了服务器的压力，提高了并发的上限！！
      这样处理，会导致DNS解析的数量增加，我们还需要优化一下：DNS预获取（DNS Prefetch），原理就是利用了<link>的异步性，把GUI渲染和域名解析同时进行了！！

  第四步：TCP的三次握手
    TCP和UDP通信协议(或机制)
      TCP：稳定可靠「基于三次握手来创建一个稳定的传输通道，在传输过程中，保障了传输信息的完整性」，但是慢！一般我们开发的项目，用的就是TCP！！
      UDP：快，但是不一定靠谱「因为信息是直接传输，不进行任何的稳定性校验」；一般直播类的项目，用的是UDP；

  第五步：HTTP数据传输
    阶段1：请求阶段 Request
      客户端向服务器发送请求，把信息传递给服务器
        + URL问号传参
        + 请求头
        + 请求主体
    阶段2：响应阶段 Response
      服务器收到请求后，把客户端需要的信息返回给客户端
        + 响应头
        + 响应主体
    -----
    HTTP事务：一次完整的请求+响应
    HTTP报文：请求+响应阶段传输的所有内容，统称为HTTP报文「控制要台->network」
      起始行：请求起始行、响应起始行
      头(首部)：请求头、响应头
      主体：请求主体、响应主体
    ----
    后期和服务器之间进行数据通信，如果发现有问题，如何调试？
      涉及客户端和服务器之间通信的问题，主要看NetWork「也就是报文信息」
      首先：看请求报文「看是否按照服务器的要求，把信息传递过去了」
      其次：再看响应报文「看服务器返回的信息是否是对的」
      最后：看我们获取数据后的处理是否正确
    ----
    HTTP网络状态码：服务器返回的一个信息，会根据不同的状态码，告知客户端处理的结果
      200 OK 成功「服务器已经把信息给客户端了」
      206 Partial Content 返回了部分内容「用户断点续传」
      ---
      301 Moved Permanently 永久转移(永久重定向)「一般用于域名变更」
      302 Move Temporarily 临时转移(或临时重定向 -> 307 Temporary Redirect) 「用于服务器负载均衡」
      304 Not Modified 协商缓存
      ---
      400 Bad Request 请求出现问题「可能是传参问题」
      401 Unauthorized 无权限访问
      403 Forbidden 服务器拒绝访问，具体的原因不告诉你
      404 Not Found 请求地址有误
      405 Method Not Allowed 请求方式不被允许
      408 Request Timeout 请求超时
      ---
      500 Internal Server Error 未知的服务器错误
      502 Bad Gateway 网关出现问题
      503 Service Unavailable 服务器超负荷

  第六步：TCP四次挥手
    目的：把建立的传输通道关闭
    如果每一次请求都三握四挥，非常浪费时间，我们期望建立的通道可以多次使用，此时需要开启 Connection: keep-alive「长链接  HTTP1.1版本默认就开启了」 => 服务器可以指定何时销毁通道「可以是指定时间，也可以是指定次数」

  第七步：浏览器渲染解析
    DOM TREE -> CSSOM TREE -> RENDER TREE -> Layout（重新Layout被称为回流(重排)） -> 分层 -> Painting（重新Painting被称之为重绘）


