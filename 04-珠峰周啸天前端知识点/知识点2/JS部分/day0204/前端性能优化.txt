第一个方面：减少HTTP请求的次数和大小
  + JS/CSS资源尽可能合并为一个，并且进行压缩！！
  + 开启服务器端的GZIP压缩！这样可以让每一次通信的资源的大小降低60%+！
  + 减少cookie的本地存储「每一次向服务器发送请求，都会自动把本地设置的cookie信息传递给服务器」
  + 尽可能进行封装，减少代码的冗余，降低文件的大小！！
 
针对于图片这一方面，我们一般也会做一些优化，例如：
  + 使用字体图标和矢量图代替位图「减少资源的请求，而且矢量图和字体图表不会因为放大缩小而失帧等」
  + 如果使用位图，可以选择webp格式「webp < jpg/jpeg < png < gif」，因为体积会更小一些
  + 使用雪碧图：把多张图合并在一起，基于background-position，去渲染指定的图片；这样可以减少图片的请求次数！！
  + 图片/音视频资源，进行懒加载处理「加快页面第一次渲染的速度」
  + 在保证图片不失帧的情况下，尽可能对图片进行压缩，以此来减少获取资源的大小！！
  + 图片资源可以开启BASE64！「但是要合理使用：BASE64码会很多，不方便开发维护(可以基于webpack解决)；BASE64也会增加其他资源的大小；如果某一张图片很重要，需要页面第一次渲染的时候就加载，为了加快其渲染的速度，可以使用BASE64；真实开发的时候，我们会对指定大小的图片，统一做base64(webpack处理)！」

为了让页面第一次渲染速度更快，我们也会做一些优化：
  + 资源分服务器进行部署！采用DNS预解析!
  + 静态资源文件开始CDN加速！
  + 可以采用HTTP2.0版本代替HTTP1.1版本!!
  + 减少HTML结构的层级嵌套，标签尽可能语义化处理，这样可以加快DOM TREE的构建！！
  + CSS资源的导入：放在HEAD中，使用内嵌式或者<link>、不用@import导入式（因为其会阻塞GUI的渲染）！
  + <script>资源的获取，基于async/defer设置为异步，不让其阻碍GUI的渲染，且尽可能放在页面的尾部！！

当然更主要的是，使用骨架屏技术，来优化页面第一次渲染！！
  + 服务器骨架屏：服务器SSR渲染「一般首屏基于服务器进行渲染」
    vue -> node + nuxt.js
    react -> node + next.js
  + 客户端骨架屏：另类的Loading效果

对于信息的缓存方面，也做了一些处理：
  + 静态资源文件开启强缓存和协商缓存「注意:html不要设置强和缓存」，这样可以加快页面第二次及以后的访问速度！
  + 对于ajax获取的数据，如果服务器返回的数据过多，也采用懒加载或者分页技术！！
  + 对于不经常更新的数据，可以基于本地存储做数据缓存！！

也会注意一些其他的优化，让页面运行时的性能更好一些：
  + 合理使用闭包「因为闭包会消耗内存」,避免内存泄漏，及时释放没用的内存！！
  + 函数的防抖和节流
  + 对于动画处理，优先使用C3动画「CSS3动画性能最好」,如果用JS动画，可以用requestAnimationFrame代替定时器！！
  + 减少DOM的操作，主要是减少DOM的回流和重绘！！
  + 使用事件委托实现事件的绑定！！
  + 避免使用CSS表达式「在CSS中写JS代码」
  + CSS选择器的前缀不宜过长「因为选择器的渲染是从右到左渲染的」
  + 代码中不要出现死递归和死循环！
  + JS代码中不要出现with语句，少使用eval等操作，因为他们很耗性能！！
  + 减少Table的使用，也是因为其耗性能！！
  + JS循环的性能：for/while > forEach > for.of > for/in「能不用则不用」

等等.....

================
可以采用 web scoket 技术，来实现数据的实时通信！！
  + 传统方案：ajax轮询「也就是设置定时器，实时向服务器发送请求」
  + 新方案：scoket.io「客户端和服务器之间建立一个长连接，服务器有最新的数据后，会主动向客户端推送」