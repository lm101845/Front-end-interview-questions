/* 
扫盲：
  1. 进程和线程
    进程代表的是一个程序，线程是程序中具体干活的；一个进程中，可能包含一到多个线程！
    浏览器打开一个页面，就是开辟一个“进程”！浏览器是多线程的！
      + GUI渲染线程：用来自上而下渲染解析HTML/CSS代码，以及绘制页面的
      + JS引擎线程：专门用来渲染解析JS代码的
      + HTTP网络线程：我们从服务器获取资源，都是基于这个线程处理的「同源下，最多只允许同时开辟5~7个」
      + 定时器监听线程：监听定时器是否到时间
      + 事件监听线程：监听事件是否被触发
      + ...
    同步编程：因为只有一个线程，所以同时只能做一件事，上一件事做完，下一件事情才能处理
    异步编程：因为有多个线程操作，所以同时可以处理多件事情「某件事没处理完，我们交给其它线程继续处理，这样不影响下面的代码继续执行」

浏览器底层渲染机制：基于HTTP网络，从服务器获取页面源代码，到浏览器渲染解析代码，绘制出我们需要的页面
  1. 创建DOM TREE（DOM树）：GUI首先渲染所有的HTML结构，计算出结构之间的层级关系
     触发DOMContentLoaded事件：window.addEventListener('DOMContentLoaded',function(){...})
  2. 创建CSSOM TREE（样式树）：等待所有CSS资源都获取后，GUI按照原先导入的顺序，依次解析CSS代码
  3. 把DOM TREE 和 CSSOM TREE 合并在一起，创建出 RENDER TREE 「渲染树」
  4. Layout布局：根据可视窗口大小，按照RENDER TREE，计算出每个节点在视口中的位置和排版等
  5. 分层：规划出页面各个文档流(层面)中，所有节点的具体绘制步骤！！
  6. Painting绘制：GUI根据上一步计算出来的步骤，开始绘制页面即可！！
     触发load事件：window.onload=function(){...}


从服务器获取页面代码后，浏览器会开辟一个“GUI渲染线程”，自上而下依次渲染解析代码！
  @1 遇到 <link href="css资源地址"/>
    + 浏览器分配新的“HTTP线程”，去服务器获取资源
    + 此时GUI不等，继续向下渲染「异步」
    + 考虑到CSS是层叠样式表，样式是有优先级的，所以每一次在获取到CSS资源后，并不会立即交给GUI渲染解析，而是要继续等待，等待其它线程也把CSS资源获取后「如果出现很久都获取不到或者获取错误，则浏览器自动忽略」，再按照之前导入CSS的顺序，依次渲染解析CSS！

  @2 遇到 <style>内嵌样式</style>
    + 内嵌样式：获取HTML的时候，就把嵌入的样式也都获取到了！不需要再开辟HTTP线程，去服务器获取资源了！
    + 为了保证CSS渲染的顺序和样式优先级，此时GUI也不会立即渲染解析CSS代码，也要等其它CSS资源都获取到，再按照顺序进行解析！！

  @3 遇到 @import 导入式
    + 也会开辟新的HTTP线程去服务器获取资源，但是其“会阻碍GUI继续向下渲染”
    + 这种模式是同步的
    + 真实项目中，尽可能不要使用@import「除非在less/sass/stylus等预编译语言中」

  @4 遇到 <img/> 
    + 开辟新的HTTP线程去获取图片资源，GUI继续向下渲染
    + 图片资源获取后，只有GUI闲着，就立即进行渲染
    + 图片懒加载：加快页面第一次渲染的速度
      + 不让图片资源占用有并发上限的HTTP线程
      + 第一次渲染页面，不去渲染耗时间的图片
      
  @5 遇到 <script src="">
    + 默认是同步的：虽然会开辟HTTP线程去服务器获取资源，但是GUI也不会继续向下执行了「阻碍了GUI的渲染」，只有等待JS代码获取后，JS引擎线程把其执行完毕，GUI才会继续渲染！！
      存在的问题：
       + 如果把<script>放在HEAD中导入，则JS代码内是无法获取DOM元素的{原因：其阻碍GUI渲染，导致JS代码执行的时候，DOM TREE还未构建}
       + 所以我们一般都是把其放在BODY末尾导入
       + 当然也可以监听事件「DOMContentLoaded && load」，在事件中获取DOM元素
    + 设置了async属性：<script async src="">
       + 获取资源是异步的：浏览器分配HTTP线程获取JS资源，此时不阻碍GUI，GUI会继续渲染
       + 代码执行是同步的：当JS资源获取后，立即执行JS代码，阻碍GUI正在做的事情！
       特点：多个<script>设置async，最后也都是谁先获取先执行谁，没有所谓的顺序概念，一般用于不需要相互依赖的JS中！！
    + 设置defer属性：<script defer src="">
       + 和<link>非常的类似，获取和渲染代码都是异步的
       特点：多个<script>设置defer，它要等待所有资源都获取后，按照导入的先后顺序，一次渲染解析JS！！

===>总结的优化技巧
  @1 CSS「或者JS」应该进行合并压缩，减少HTTP请求的次数和大小
  @2 图片资源一定要做懒加载
  @3 样式代码较少的情况，使用内嵌式；代码较多，采用外链式；坚决不用导入式；
  @4 把<script>放在body末尾，根据依赖状况，设置async/defer让其变为异步处理！！
  ...


DOM的回流(重排 Reflow)和重绘(Repaint)
  市面上流行一句话：“操作DOM非常消耗性能”，所以目前都是基于vue/react等框架进行开发「但是框架最后也是要去操作DOM，实现页面效果的，只不过开发者操作数据，框架内部把DOM操作都封装处理好了（做了性能优化）」

  回流/重排：当我们的某些操作，让视口中的节点，位置和布局等发生变化，此时浏览器需要重新Layout，然后分层和渲染，这样非常消耗性能！「当代浏览器中，如果是除#document以外的其它层面，出现了布局或者位置改变，只需要对这一层进行重排，性能消耗小很多」
     + 哪些操作可以改变布局和位置呢：删除/新增节点、挪动节点的位置、改变其大小、视口大小改变...
     + 一但发生回流，必然会出现一次重绘
  重绘：我们修改的样式，不会引发布局和位置的变化，不需要重新Layout，只需要重新把变更的样式渲染即可
     + 哪些操作触发重绘：改变颜色、背景图、透明度、transform「内部开启了硬件加速」...
  总结：真实项目中，如果需要我们自己手动操作DOM，我们必须要减少“非必要的DOM回流/重排”

  解决方案：
    @1 读写分离：把获取元素样式和修改元素样式分离开
      当代浏览器都具备“渲染队列机制”：在当前上下文中，遇到修改元素样式的代码，浏览器不会立即渲染，而是会先放到渲染队列中...等待上下文中，所有修改样式的代码都处理完毕，浏览器再统一渲染一次「引发一次回流」！
      获取元素样式的操作，会刷新渲染队列「也就是把目前修改样式的操作立即渲染一次」！！
    @2 批量设置样式
      + 设置样式类名
      + 利用cssText处理：box.style.cssText=''
    @3 批量新增元素
      + 字符串拼接「一般用于原本容器中没有内容；如果存在内容，基于字符串拼接的方式实现新增，会对原始内容产生影响（例如：绑定的事件丢失）」
      + 文档碎片
    @4 操作一些不会引发回流的样式，来完成我们的需求，例如：
      + transform
      + opacity
      + ...
    @5 即便触发回流，我们也期望把性能消耗降到最低
      + 把需要运动的元素，单独提取到新的文档流中
      + 实现JS动画，我们可以牺牲平滑度换取速度
      + ...
*/
// let box = document.querySelector('#box'),
//     submit = document.querySelector('#submit');
// submit.onclick = function () { alert('哈哈哈哈哈') };

/* // 触发1次回流
let frag = document.createDocumentFragment(); //文档碎片：一个存放DOM节点的容器
new Array(10).fill(null).forEach((_, index) => {
    let span = document.createElement('span');
    span.innerText = index + 1;
    frag.appendChild(span); //每一次是把创建的节点放在容器中
});
box.appendChild(frag); */


/* // 触发10次回流
new Array(10).fill(null).forEach((_, index) => {
    let span = document.createElement('span');
    span.innerText = index + 1;
    box.appendChild(span);
}); */

/* let str = ``;
new Array(10).fill(null).forEach((_, index) => {
    str += `<span>
        ${index + 1}
    </span>`;
});
box.innerHTML += str; //把之前的内容当做字符串获取到，和新的字符串拼接在一起，最后整体再放回去！ */



/* box.style.width = '100px';
box.style.height = '100px';
console.log(box.offsetWidth);
let n = 10;
box.style.margin = n + 'px';
box.style.padding = '5px'; */