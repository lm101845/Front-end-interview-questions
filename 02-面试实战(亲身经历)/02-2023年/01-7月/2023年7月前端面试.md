# 2023年7月前端面试

## 法本一面(7-13)

### 有用到一些组件库吗

element-ui、vant(有赞移动端)、ant-design(蚂蚁金服)

### Vue的双向绑定原理

(为什么vue把数据写在data里面，data数据变化，页面也会变化，原理是什么)

https://zhuanlan.zhihu.com/p/138710460

https://juejin.cn/post/7065967379095748638

Vue数据双向绑定原理是通过**数据劫持**结合**发布者-订阅者模式**的方式来实现的，首先是对数据进行监听，然后当监听的属性发生变化时则告诉订阅者是否要更新，若更新就会执行对应的更新函数从而更新视图。

Vue将数据写在data中是为了实现数据的响应式，即当数据发生变化时，页面能够自动更新。

Vue的响应式原理是通过使用Object.defineProperty方法对data中的每个属性进行劫持，当属性被访问或修改时，会触发相应的getter和setter方法。在getter方法中，会将当前的依赖收集起来，当属性被修改时，会通知所有依赖进行更新。

具体的实现步骤如下：
1. 在Vue实例化时，会将data中的每个属性转化为getter和setter，并进行**依赖收集**；
2. 当页面渲染时，会触发属性的getter方法，将依赖收集到当前的Watcher对象中；
3. 当属性被修改时，会触发setter方法，通知所有依赖进行更新；
4. 更新时，会重新渲染页面，将变化的数据显示在页面上。

**接下去我们执行以下3个步骤，实现数据的双向绑定：**

- （1）实现一个**监听器Observer(Object.defineProperty( ))**，用来**劫持并监听所有属性**，如果有变动的，就通知订阅者。
- （2）实现一个**订阅者Watcher**，**每一个Watcher都绑定一个更新函数**，watcher可以**收到属性的变化**通知并执行相应的函数，从而更新视图。
- （3）实现一个**解析器Compile**，可以**扫描和解析每个节点的相关指令（v-model，v-on等指令）**，如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。

### v-model

分两步骤

1. v-bind绑定一个value属性
2. v-on指令给当前元素绑定input事件

~~~
 <input type="text" :value="msg" @input="change">
~~~

v-model是Vue.js框架中的一个指令，用于实现双向数据绑定。它的原理是通过监听输入框的输入事件，将输入的值实时更新到Vue实例的data中，同时也通过监听data中的值的变化，将最新的值实时更新到输入框中。

具体实现原理如下：

1. 在Vue实例中使用v-model指令**绑定一个数据属性**和一个**表单元素（如输入框）**。
2. 当用户在表单元素中输入内容时，会**触发输入事件**，Vue会**监听**到这个事件。
3. Vue会将用户输入的内容**更新到绑定的数据属性**中，从而实现数据的双向绑定。
4. 同时，Vue还会将数据属性的变化反映到表单元素中，将最新的值显示给用户。

通过v-model指令，Vue实现了数据的双向绑定，使得用户在表单元素中输入内容时，数据会自动更新；同时，当数据属性的值发生变化时，表单元素也会自动更新，保持与数据的同步。

这种双向数据绑定的原理使得开发者无需手动监听输入事件和数据变化事件，简化了开发流程，提高了开发效率。同时，也提升了用户体验，使得用户在输入内容时能够实时看到数据的变化。

### Vue原理：如何对数组进行数据劫持

https://juejin.cn/post/7030256312835375141

`Vue`在数据劫持中对于数组特殊处理的原因：

使用`Object.defineProperty`并不会对数据的索引进行劫持,比如我现在有一个数组,长度是100000,如果对每个索引都进行劫持,那么就需要将劫持100000次,所以劫持数组会造成性能问题，性能代价和用户体验收益不成正比

在日常开发过程中,我们也很少会直接通过数组的索引去操作数组,这样是存在问题的,因为数组是会一直在变化的,如果数据改变,那么通过索引获取到的数据并不是期望获得的,大部分都是通过数组的原型方法`psuh`、`pop`等方法操作,因此将数组的7个可以改变数组本身的函数进行了代理。

### Vue的diff算法

https://juejin.cn/post/6844903607913938951?searchId=202307131701297F69D533D776CC79480F

https://zhuanlan.zhihu.com/p/81752104

我们先根据真实DOM生成一颗`virtual DOM`，当`virtual DOM`某个节点的数据改变后会生成一个新的`Vnode`，然后`Vnode`和`oldVnode`作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使`oldVnode`的值为`Vnode`。

diff的过程就是调用名为`patch`的函数，比较新旧节点，一边比较一边给**真实的DOM**打补丁。

采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。

======================================================================================

Vue的diff算法的实现位于Vue源码的`src/core/vdom/patch.js`文件中。在该文件中，定义了`patch`函数，用于比较虚拟DOM树的差异并将差异应用到真实DOM上。

`patch`函数的主要逻辑如下：
1. 首先判断新旧虚拟DOM节点是否相同，如果相同，则直接返回，不进行进一步的比较。
2. 如果新旧节点不同，则判断新旧节点的类型，根据类型的不同，调用相应的处理函数。
3. 在处理函数中，会比较节点的属性、子节点等差异，并根据差异类型进行相应的更新操作，如插入、删除、替换等。
4. 如果存在子节点，则递归调用`patch`函数进行子节点的比较和更新。
5. 最后，将更新后的真实DOM返回。

在`patch`函数中，还会调用其他辅助函数，如`createElm`、`removeNode`、`insertBefore`等，用于创建、移除、插入真实DOM节点。

需要注意的是，Vue的diff算法并没有完全按照传统的虚拟DOM的diff算法实现，而是结合了一些优化手段，如静态模板标记、动态模板标记、Patch Flag等，以提高比较效率和渲染性能。这些优化手段的具体实现也可以在`src/core/vdom/patchFlag.js`和`src/core/vdom/patchFlags.js`等文件中找到。

### Vue中watch和computed的区别

[Vue中的computed(计算属性)和watch(监听属性)的区别](https://blog.csdn.net/weixin_43745075/article/details/115641873)

**计算属性computed :**

* 支持**缓存**，只有依赖数据发生改变，才会重新进行计算
* 不支持**异步**，当computed内有异步操作时无效，无法监听数据的变化
* computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是**基于data**中声明过或者**父组件传递的props**中的数据通过计算得到的值
* 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
* 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；**在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法**。

**侦听属性watch：**

* **不支持缓存**，数据变，直接会触发相应的操作；

* watch**支持异步**；

* 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

* 当一个属性发生变化时，需要执行对应的操作；一对多；

* 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，
  * immediate：组件加载立即触发回调函数执行，
  * deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

```
我之前简单看过Vue的源码，通过分析源码发现，不论是 watch 还是 computed，最后都是基于 Watcher 这个类实现监听处理的！而 watch 和 computed，基本上都是通过监听某些状态值的改变，从而做一些处理！真实项目中，有的需求，用两者任何一种方式都可以实现，具体选择谁，可以看具体的需求！
  @1 如果是依赖一到多个状态，但是最后要算出一个新的值，此时用 computed 更好，因为其除了可以“自动监听”使用的依赖之外，还具备计算缓存的效果，有助于性能的提高！
  @2 如果是多个状态值改变，需要处理相同的事情，用 watch 处理，需要对这几个状态依次进行监听，而 computed 只需要写一个函数，函数中用到这几个状态即可！所以用 computed 可能更方便！
  @3 但是，如果就是想监听某个值的变化后，做点啥事（做的事情，也不一定是算新的值），此时基于 watch 处理即可！！
当然，从使用语法上，watch 和 computed要注意一个区别：
  + watch是监听现有状态，也就是监听的内容必须是已经存在的
  + 而computed是创建一个新的状态，并且挂载到了实例上，所以不能和现有状态/属性/方法的名字一致
所以，在我做项目开发的时候，遇到需求后，一般都是优先考虑 computed 计算属性，能用其解决的，就用它解决了！实在不合适的情况下，我才使用 watch！
```

### Vue2里面data为什么不能写成对象

每声明一个组件都是通过vue.extend这个api，在里面需要传入options，里面包含data。如果data是一个对象，则所有组件都会指向同一个data，而是一个函数的话，通过函数来返回一个对象，就可以保证这个对象是自己独有的，防止属性之间污染。

如果vue组件中的data是对象，我们在几个地方使用一个组件，那么因为此时的几个组件中的数据引用的都是同一个内存地址，更改一个组件的时候其他组件也会受影响，数据污染产生

所以[vue2](https://so.csdn.net/so/search?q=vue2&spm=1001.2101.3001.7020)中组件中的data是函数而不是对象。

### Vue里面怎么使用插件的

插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

添加**全局方法**或者 property。如：vue-custom-element

添加**全局资源**：指令/过滤器/过渡等。如 vue-touch

通过**全局混入**来添加一些组件选项。如 vue-router

**添加 Vue 实例方法**，通过把它们添加到 Vue.prototype 上实现。

===============================================================

插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：

1. 通过 [`app.component()`](https://cn.vuejs.org/api/application.html#app-component) 和 [`app.directive()`](https://cn.vuejs.org/api/application.html#app-directive) 注册一到多个全局组件或自定义指令。
2. 通过 [`app.provide()`](https://cn.vuejs.org/api/application.html#app-provide) 使一个资源[可被注入](https://cn.vuejs.org/guide/components/provide-inject.html)进整个应用。
3. 向 [`app.config.globalProperties`](https://cn.vuejs.org/api/application.html#app-config-globalproperties) 中添加一些全局实例属性或方法
4. 一个可能上述三种都包含了的功能库 (例如 [vue-router](https://github.com/vuejs/vue-router-next))。

### Vue常见路由有哪些

https://juejin.cn/post/6861586972696444942

路由是由多个URL组成的，使用**不同的URL可以相应的导航到不同的位置**。如果有进行过服务器开发或者对http协议有所了解就会知道，浏览器中对页面的访问是无状态的，所以**我们在切换不同的页面时都会重新进行请求**。而实际使用vue和vue-router开发就会明白，**在切换页面时是没有重新进行请求也没有重新刷新页面**，使用起来就好像页面是有状态的，这是什么原因呢。这其实是**借助了浏览器的History API**来实现的，这样可以**使得页面跳转而不刷新，页面的状态就被维持在浏览器中了**。

* hash模式

使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载，其显示的网路路径中会有 “#” 号，有一点点丑。这是最安全的模式，因为他兼容所有的浏览器和服务器。

* history模式

美化后的hash模式，会去掉路径中的 “#”。依赖于Html5 的history，pushState API,所以要担心IE9以及一下的版本，感觉不用担心。并且还包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作。就是浏览器左上角的前进、后退等按钮进行的操作。
但是history也是有缺点的，不怕前进后退跳转，就怕刷新（如果后端没有准备的话），因为刷新是实实在在地去请求服务器了。**浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404 了。**

* abstract模式

适用于所有JavaScript环境，例如服务器端使用Node.js。如果没有浏览器API，路由器将自动被强制进入此模式。

### Vue数据通讯有哪些

### https://juejin.cn/post/7038457201052090376

https://juejin.cn/post/6844903845642911752

vue是数据驱动视图更新的框架, 我们平时开发，都会把页面不同模块拆分成一个一个vue组件， 所以对于vue来说组件间的数据通信非常重要，那么组件之间如何进行数据通信的呢？

首先我们需要知道在vue中组件之间存在什么样的关系, 才更容易理解他们的通信方式。

一般我们分为如下关系：

- 父子组件之间通信
- 非父子组件之间通信(兄弟组件、隔代关系组件等)

#### props / $emit

**prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。**

第一，不应该在一个子组件内部改变 prop，这样会破坏单向的数据绑定，导致数据流难以理解。如果有这样的需要，可以通过 data 属性接收或使用 `computed` 属性进行转换。

第二，如果 `props` 传递的是`引用类型(对象或者数组)`，在子组件中改变这个对象或数组，父组件的状态会也会做相应的更新，利用这一点就能够实现父子组件数据的`“双向绑定”`，虽然这样实现能够节省代码，但会`牺牲数据流向的简洁性`，令人难以理解，最好不要这样去做。

想要实现父子组件的数据“双向绑定”，可以使用 `v-model` 或 `.sync`。

#### v-model 指令

`v-model` 是用来在`表单控件`或者`组件`上创建`双向绑定`的，他的本质是 `v-bind` 和 `v-on` 的`语法糖`，在一个组件上使用 `v-model`，默认会为组件绑定名为 `value 的 prop` 和名为 `input` 的事件。

当我们组件中的某一个 `prop` 需要实现上面所说的”双向绑定“时，`v-model` 就能大显身手了。有了它，就不需要自己手动在组件上绑定监听当前实例上的自定义事件，会使`代码更简洁`。

### 介绍Vuex和命名空间

https://blog.csdn.net/Lxy_5201314/article/details/107623623

https://blog.csdn.net/cherry_vicent/article/details/122449617?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122449617-blog-119879218.235%5Ev38%5Epc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122449617-blog-119879218.235%5Ev38%5Epc_relevant_anti_vip&utm_relevant_index=2

#### vuex中commit和dispatch的区别

https://blog.csdn.net/zhanggqianglovec/article/details/124443677?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124443677-blog-105601115.235

### 手写防抖函数

https://juejin.cn/post/6844904185117278215

https://juejin.cn/post/6916386899678461960

https://juejin.cn/post/7032905194736189477

##### 防抖：等你歇菜了我再上

**概念：** `在事件被触发，并不立即执行，而是等待n秒后执行回调，如果在这n秒内又被触发，则重新计时。`

**生活中的实例：** `如果有人进电梯（触发事件），电梯并不会立马就出发，而是在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。`

**防抖的过程,看成一个英雄在技能读条,只有技能读条结束了,技能才能扔出来.要是中途被人打断了,那么下次又要重新读条了.**

~~~
函数防抖代码的实现一般是根据setTimeout来实现。每次进入都会去执行setTimeout，但是如果已经有setTimeout在执行，则会先销毁执行的setTimeout，再创建一个新的setTimeout。保证只有一个setTimeout并且在指定时间后执行。

        function debounce(fn,wait){
            let timer = null
            return function(){
                let args = arguments
                clearTimeout(timer)
                // 先去掉之前的定时器
                timer = setTimeout(()=>{
                    // 唉，我他娘的apply还是不熟啊！！
                    fn.apply(this,args)
                },wait)
            }
        }
        
        
这段代码实现了一个防抖函数。防抖函数的作用是在事件触发后延迟一段时间再执行回调函数，如果在这段时间内再次触发了事件，则重新计时。

函数接受两个参数：fn是回调函数，wait是延迟时间。

在函数内部，定义了一个timer变量用于存储定时器的ID。然后返回一个匿名函数作为防抖函数的实际执行体。

每次调用防抖函数时，首先保存当前的参数args，并清除之前的定时器。然后创建一个新的定时器，在延迟时间wait之后执行回调函数fn，并将之前保存的参数args传递给回调函数。

这样做的效果是，如果在延迟时间内再次调用防抖函数，会先清除之前的定时器，然后重新创建一个新的定时器，重新计时。只有在延迟时间内没有再次触发事件，才会执行回调函数。这样可以避免频繁触发事件导致回调函数被频繁执行的问题。
~~~



##### 节流：管你频率那么快,我就保持自己的节奏

**概念：** `规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。`高频事件触发,但是在n秒内只会执行一次,会稀释函数的执行频率

**生活中的实例：** `我们知道目前的一种说法是当 1 秒内连续播放 24 张以上的图片时，在人眼的视觉中就会形成一个连贯的动画，所以在电影的播放（以前是，现在不知道）中基本是以每秒 24 张的速度播放的，为什么不 100 张或更多呢？是因为 24 张就可以满足人类视觉需求的时候，100 张就会显得很浪费资源。`

~~~
        function throttle(fn, wait) {
            let timer = null;
            return function () {
                let args = arguments
                if (!timer) {
                    timer = setTimeout(() => {
                        timer = null
                        fn.apply(this, args)
                    }, wait)
                }
            }
        }
~~~

### promise与async、await

概括的说，一个函数如果加上 async ，那么该函数就会返回一个 Promise。

await 只能在 async 函数中使用，可以把 async 看成将函数返回值使用 Promise.resolve() 包裹了下。

async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。

================================================================

js 是单线程的（重复三遍），所谓单线程，

意思就是说：执行代码是一行一行的往下走（即所谓的同步），

如果上面的没执行完，那就只能等着。

上面仅仅是一个 for 循环，而在实际应用中，会有大量的网络请求，它的响应时间是不确定的，这种情况下也要等待吗？

显然是不行的，因而 js 设计了异步，即 发起网络请求（诸如 IO 操作，定时器），由于需要等服务器响应，就先不理会，而是去做其他的事儿，等请求返回了结果的时候再说（即异步）。

那么如何实现异步呢？其实我们平时已经在大量使用了，那就是 callback，实现异步的核心就是回调钩子，将 cb 作为参数传递给异步执行函数，当有了结果后在触发 cb。想了解更多，可以去看看 event-loop 机制。

之前这种函数嵌套，大量的回调函数，使代码阅读起来晦涩难懂，不直观，形象的称之为回调地狱（callback hell），所以为了在写法上能更通俗一点，es6+陆续出现了 Promise、Generator、Async/await，力求在写法上简洁明了，可读性强。

async/await 是参照 Generator 封装的一套异步处理方案，可以理解为 Generator 的语法糖，

#### Promise内部原理是什么

#### Promise.then返回什么

~~~
Promise.then方法返回一个新的Promise对象。这个新的Promise对象的状态和值取决于前一个Promise对象的状态和回调函数的返回值。

如果前一个Promise对象的状态是fulfilled（已完成），则新的Promise对象的状态也是fulfilled。回调函数的返回值会作为新的Promise对象的值。

如果前一个Promise对象的状态是rejected（已拒绝），则新的Promise对象的状态也是rejected。回调函数的返回值会被忽略。

无论前一个Promise对象的状态是fulfilled还是rejected，Promise.then方法都会返回一个新的Promise对象，因此可以通过链式调用then方法来处理多个异步操作。每个then方法都可以注册一个回调函数，用于处理前一个Promise对象的结果。
~~~

#### Promise扩展API

Promise.all方法会按照传入的Promise数组的顺序返回结果。当所有的Promise都成功时，Promise.all会返回一个新的Promise对象，该Promise对象的状态为fulfilled，并且返回一个包含所有Promise结果的数组，结果的顺序与传入的Promise数组的顺序一致。

如果其中一个Promise失败（即被rejected），Promise.all会立即将**整个**Promise.all的返回的Promise对象的状态设为rejected，并返回一个带有失败原因的错误对象。此时，Promise.all不会等待其他Promise的完成，而是立即返回失败结果。

总结起来，Promise.all方法会按顺序返回结果，但如果其中一个Promise失败，整个Promise.all的返回结果会立即失败。
Promise.all默认只要有一个错误就直接返回错误。promise.all中任何一个promise 出现错误的时候都会执行reject，导致其它正常返回的数据也无法使用

==========================================================================

当使用`Promise.all`方法时，如果其中一个Promise被拒绝（失败），则`Promise.all`返回的Promise也会被拒绝，并且会返回第一个被拒绝的Promise的值。

因此，如果其中一个Promise被拒绝，其他Promise的结果将不会被捕获或返回。只有当所有的Promise都成功时，`Promise.all`才会返回一个包含所有成功值的数组。

如果你想要获取所有成功的值，即使其中一个Promise被拒绝，可以使用`Promise.allSettled`方法。该方法返回一个Promise，该Promise在所有传入的Promise都已解决（无论是成功还是失败）后解决，并且返回一个包含每个Promise结果的数组，每个结果都包含`status`（fulfilled或rejected）和`value`（解决值或拒绝原因）属性。

===============================================================================

Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1在前，即便p1的结果获取的比p2要晚。p1的返回数据也会在p2前面。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景。

=========================================================

#### Promise源码

## 华云信息一面

### 介绍一下最有挑战的2个项目

项目中遇到的问题，基本上和安卓/IOS适配有关。比如货币基金H5输出联通渠道，当时使用的input输入框来实现身份证信息上传，要求可以用拍照和上传图片，但是安卓和IOS表现不一样，有的只能拍照，有的只能上传照片。

大额存单项目：逻辑比较复杂

uniapp项目，头部被遮挡，底部被遮挡

### Vue2和Vue3的区别

https://juejin.cn/post/7067413380922867725

* 生命周期

* 可以有多根节点

* Composition API

  * Vue2 是选项API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置。

    Vue3 组合式API（Composition API）则很好地解决了这个问题，可**将同一逻辑的内容写到一起**，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案。

* 响应式原理
* Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy。
* Diff算法优化

### Vue2怎么对数组进行监听

当给数组某一项赋值的时候，触发了 setter，setter 的时候，打印 obj 数组又依次读取了数组的值，这会影响性能。另外很多时候数组长度我们并不确定，无法提前打上 getter/setter，而且如果数组长度很大也会造成性能问题，用尤大的原话说就是性能代价和获得的用户体验收益不成正比。

理论上 vue 是可以这样做，但是出于性能考虑没这样做，而是用了一种数组变异办法来触发视图更新。

vue 出于性能的考虑，没有用 Object.defineProperty 去监听数组，而是通过覆盖数组的原型的方法，对常用的七种方法进行了变异，以此来实现对数组的监听。

### Vue2的mixins存在的问题

https://blog.csdn.net/m0_47135993/article/details/124450241

https://blog.csdn.net/z591102/article/details/106682344

官方描述是混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。

mixins特点：
1.方法和参数在组件中不共享，虽然组件调用了mixins并将其属性合并到自身组件中来了，但是其属性只会被当前组件所识别并不会被共享，也就是其他组件无法从当前组件中获取到mixins中的数据和方法。
2.引入mixins后组件会对其进行合并，将mixins中的数据和方法扩展到当前组件中来，在合并的过程中如果出现冲突，当出现冲突时：
2.1.值为对象（components、methods、computed、data）的选项，混入组件时选项会被合并，键冲突时优先组件，组件中的键会被覆盖混入对象的。（组件和mixins冲突时，比如说都有age数据和getAge方法，以组件本身的优先）
2.2.值为函数（created、mounted）的选项，混入组件时会被合并调用，混合对象里的钩子函数在组件里的钩子函数前调用。（例如，mixins中的created早于组件本身的created调用）
与vuex区别
vuex：用来做状态管理的，里面定义的变量在每个组件中均可使用和修改，在任一组件中修改此变量值后，其他组件中此变量的值会随之修改。
mixins：可以定义公共的变量，在每个组件中使用，引入组件后，各个变量是相互独立的，值的修改在组件中不会相互影响，只作用于当前引入的组件中。
与公共组件的区别
组件：在父组件中引入组件，相当于父组件中给出一片独立的空间供自组件使用，然后根据props来传值，但本质上两者是相对独立的。
mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象和方法，可以理解为形成了一个新的组件。

缺点：

* 变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护。——复用的同时降低了代码可读性

* 多个mixins的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突或覆盖。

  (引入了两个minix，而两个文件中都存在一个相同名字的方法，后引入的文件会覆盖掉前一个文件的方法)

* mixins和组件可能出现多对多的关系，复杂度较高

mixin很容易发生冲突：因为mixin中的property都被合并到了一个组件中，同名的会被覆盖，需要了解每一个选项默认的合并特性

数据来源不明确：如果你引入了多个mixin对象，那你想要知道其中一个具体方法、属性等的来源无疑是很难查找的

可重用性有限：**我们只能被动的使用mixin中传递的任何东西，而不能通过参数传递的方式来改变其中的某些逻辑，这大大降低了它抽象逻辑方面的灵活性**

vue3没有mixin,也不需要mixin，使用组合式API。在Composition API中，我们可以抽离出每一个逻辑点为单独的js文件，再通过import的方式去把页面的所有内容组合在一起，实现一个完整的页面。

同样的，如果多个页面、组件，用到的方法、变量都是同样的，那么我们可以把这一个js文件同时引入到多个文件中，然后再进行使用，这也就达到了mixin的效果，甚至我们可以通过接受参数的方式对公共的方法作出定制化处理。

### Vue3的ref和reactive









